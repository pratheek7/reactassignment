{"ast":null,"code":"/**\n * Copyright IBM Corp. 2016, 2022\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { typeof as _typeof } from '../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { getCellId } from './cells.js';\nimport { sortStates } from '../state/sortStates.js';\n\n/**\n * Compare two primitives to determine which comes first. Initially, this method\n * will try and figure out if both entries are the same type. If so, it will\n * apply the default sort algorithm for those types. Otherwise, it defaults to a\n * string conversion.\n *\n * @param {number|string} a\n * @param {number|string} b\n * @param {string} locale\n * @returns {number}\n */\n\nvar compare = function compare(a, b) {\n  var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a - b;\n  }\n  if (typeof a === 'string' && typeof b === 'string') {\n    return compareStrings(a, b, locale);\n  } // if column has React elements, this should sort by the child string if there is one\n\n  if (_typeof(a) === 'object' && _typeof(b) === 'object') {\n    if (typeof a.props.children === 'string' && typeof b.props.children === 'string') {\n      return compareStrings(a.props.children, b.props.children, locale);\n    }\n  }\n  return compareStrings('' + a, '' + b, locale);\n};\n/**\n * Use the built-in `localeCompare` function available on strings to compare two\n * strings.\n *\n * @param {string} a\n * @param {string} b\n * @param {string} locale\n * @returns {number}\n */\n\nvar compareStrings = function compareStrings(a, b) {\n  var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';\n\n  // Only set `numeric: true` if the string only contains numbers\n  // https://stackoverflow.com/a/175787\n  if (!isNaN(a) && !isNaN(parseFloat(a))) {\n    return a.localeCompare(b, locale, {\n      numeric: true\n    });\n  }\n  return a.localeCompare(b, locale);\n};\n/**\n * Default implementation of how we sort rows internally. The idea behind this\n * implementation is to use the given list of row ids to look up the cells in\n * the row by the given key. We then use the value of these cells and pipe them\n * into our local `compareStrings` method, including the locale where\n * appropriate.\n *\n * @param {object} config\n * @param {Array[string]} config.rowIds array of all the row ids in the table\n * @param {object} config.cellsById object containing a mapping of cell id to\n * cell\n * @param {string} config.key the header key that we use to lookup the cell\n * @param {string} [config.locale] optional locale used in the comparison\n * function\n * @param {string} config.sortDirection the sort direction used to determine the\n * order the comparison is called in\n * @param {Function} config.sortRow\n * @returns {Array[string]} array of sorted rowIds\n */\n\nvar sortRows = function sortRows(_ref) {\n  var rowIds = _ref.rowIds,\n    cellsById = _ref.cellsById,\n    sortDirection = _ref.sortDirection,\n    key = _ref.key,\n    locale = _ref.locale,\n    sortRow = _ref.sortRow;\n  return rowIds.slice().sort(function (a, b) {\n    var cellA = cellsById[getCellId(a, key)];\n    var cellB = cellsById[getCellId(b, key)];\n    return sortRow(cellA && cellA.value, cellB && cellB.value, {\n      key: key,\n      sortDirection: sortDirection,\n      locale: locale,\n      sortStates: sortStates,\n      compare: compare\n    });\n  });\n};\nvar defaultSortRow = function defaultSortRow(cellA, cellB, _ref2) {\n  var sortDirection = _ref2.sortDirection,\n    sortStates = _ref2.sortStates,\n    locale = _ref2.locale;\n  if (sortDirection === sortStates.ASC) {\n    return compare(cellA, cellB, locale);\n  }\n  return compare(cellB, cellA, locale);\n};\nexport { compare, compareStrings, defaultSortRow, sortRows };","map":{"version":3,"names":["typeof","_typeof","getCellId","sortStates","compare","a","b","locale","arguments","length","undefined","compareStrings","props","children","isNaN","parseFloat","localeCompare","numeric","sortRows","_ref","rowIds","cellsById","sortDirection","key","sortRow","slice","sort","cellA","cellB","value","defaultSortRow","_ref2","ASC"],"sources":["C:/Users/Administrator/Desktop/nerf/node_modules/@carbon/react/es/components/DataTable/tools/sorting.js"],"sourcesContent":["/**\n * Copyright IBM Corp. 2016, 2022\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { typeof as _typeof } from '../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { getCellId } from './cells.js';\nimport { sortStates } from '../state/sortStates.js';\n\n/**\n * Compare two primitives to determine which comes first. Initially, this method\n * will try and figure out if both entries are the same type. If so, it will\n * apply the default sort algorithm for those types. Otherwise, it defaults to a\n * string conversion.\n *\n * @param {number|string} a\n * @param {number|string} b\n * @param {string} locale\n * @returns {number}\n */\n\nvar compare = function compare(a, b) {\n  var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';\n\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a - b;\n  }\n\n  if (typeof a === 'string' && typeof b === 'string') {\n    return compareStrings(a, b, locale);\n  } // if column has React elements, this should sort by the child string if there is one\n\n\n  if (_typeof(a) === 'object' && _typeof(b) === 'object') {\n    if (typeof a.props.children === 'string' && typeof b.props.children === 'string') {\n      return compareStrings(a.props.children, b.props.children, locale);\n    }\n  }\n\n  return compareStrings('' + a, '' + b, locale);\n};\n/**\n * Use the built-in `localeCompare` function available on strings to compare two\n * strings.\n *\n * @param {string} a\n * @param {string} b\n * @param {string} locale\n * @returns {number}\n */\n\nvar compareStrings = function compareStrings(a, b) {\n  var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';\n\n  // Only set `numeric: true` if the string only contains numbers\n  // https://stackoverflow.com/a/175787\n  if (!isNaN(a) && !isNaN(parseFloat(a))) {\n    return a.localeCompare(b, locale, {\n      numeric: true\n    });\n  }\n\n  return a.localeCompare(b, locale);\n};\n/**\n * Default implementation of how we sort rows internally. The idea behind this\n * implementation is to use the given list of row ids to look up the cells in\n * the row by the given key. We then use the value of these cells and pipe them\n * into our local `compareStrings` method, including the locale where\n * appropriate.\n *\n * @param {object} config\n * @param {Array[string]} config.rowIds array of all the row ids in the table\n * @param {object} config.cellsById object containing a mapping of cell id to\n * cell\n * @param {string} config.key the header key that we use to lookup the cell\n * @param {string} [config.locale] optional locale used in the comparison\n * function\n * @param {string} config.sortDirection the sort direction used to determine the\n * order the comparison is called in\n * @param {Function} config.sortRow\n * @returns {Array[string]} array of sorted rowIds\n */\n\nvar sortRows = function sortRows(_ref) {\n  var rowIds = _ref.rowIds,\n      cellsById = _ref.cellsById,\n      sortDirection = _ref.sortDirection,\n      key = _ref.key,\n      locale = _ref.locale,\n      sortRow = _ref.sortRow;\n  return rowIds.slice().sort(function (a, b) {\n    var cellA = cellsById[getCellId(a, key)];\n    var cellB = cellsById[getCellId(b, key)];\n    return sortRow(cellA && cellA.value, cellB && cellB.value, {\n      key: key,\n      sortDirection: sortDirection,\n      locale: locale,\n      sortStates: sortStates,\n      compare: compare\n    });\n  });\n};\nvar defaultSortRow = function defaultSortRow(cellA, cellB, _ref2) {\n  var sortDirection = _ref2.sortDirection,\n      sortStates = _ref2.sortStates,\n      locale = _ref2.locale;\n\n  if (sortDirection === sortStates.ASC) {\n    return compare(cellA, cellB, locale);\n  }\n\n  return compare(cellB, cellA, locale);\n};\n\nexport { compare, compareStrings, defaultSortRow, sortRows };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}