{"ast":null,"code":"/**\n * Copyright IBM Corp. 2016, 2022\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar prefix = 'cds';\nfunction resetFocus(el) {\n  if (el) {\n    var _el$querySelectorAll;\n    Array.from((_el$querySelectorAll = el.querySelectorAll('[tabindex=\"0\"]')) !== null && _el$querySelectorAll !== void 0 ? _el$querySelectorAll : []).forEach(function (node) {\n      node.tabIndex = -1;\n    });\n  }\n}\nfunction focusNode(node) {\n  if (node) {\n    node.tabIndex = 0;\n    node.focus();\n  }\n}\nfunction getValidNodes(list) {\n  var level = list.dataset.level;\n  var nodes = [];\n  if (level) {\n    var submenus = Array.from(list.querySelectorAll('[data-level]'));\n    nodes = Array.from(list.querySelectorAll(\"li.\".concat(prefix, \"--menu-option\"))).filter(function (child) {\n      return !submenus.some(function (submenu) {\n        return submenu.contains(child);\n      });\n    });\n  }\n  return nodes.filter(function (node) {\n    return node.matches(\":not(.\".concat(prefix, \"--menu-option--disabled)\"));\n  });\n}\nfunction getNextNode(current, direction) {\n  var menu = getParentMenu(current);\n  var nodes = getValidNodes(menu);\n  var currentIndex = nodes.indexOf(current);\n  var nextNode = nodes[currentIndex + direction];\n  return nextNode || null;\n}\nfunction getFirstSubNode(node) {\n  var submenu = node.querySelector(\"ul.\".concat(prefix, \"--menu\"));\n  if (submenu) {\n    var subnodes = getValidNodes(submenu);\n    return subnodes[0] || null;\n  }\n  return null;\n}\nfunction getParentNode(node) {\n  if (node) {\n    var parentNode = node.parentNode.closest(\"li.\".concat(prefix, \"--menu-option\"));\n    return parentNode || null;\n  }\n  return null;\n}\nfunction getSubMenuOffset(node) {\n  if (node) {\n    var nodeStyles = getComputedStyle(node);\n    var spacings = parseInt(nodeStyles.paddingTop) + parseInt(nodeStyles.paddingBottom); // styles always in px, convert to number\n\n    var elementHeight = node.firstElementChild.offsetHeight;\n    return elementHeight + spacings || 0;\n  }\n  return 0;\n}\nfunction getParentMenu(el) {\n  if (el) {\n    var parentMenu = el.parentNode.closest(\"ul.\".concat(prefix, \"--menu\"));\n    return parentMenu || null;\n  }\n  return null;\n}\nfunction clickedElementHasSubnodes(e) {\n  if (e) {\n    var closestFocusableElement = e.target.closest('[tabindex]');\n    if ((closestFocusableElement === null || closestFocusableElement === void 0 ? void 0 : closestFocusableElement.tagName) === 'LI') {\n      return getFirstSubNode(closestFocusableElement) !== null;\n    }\n  }\n  return false;\n}\n/**\n * @param {number} [value] The value to cap\n * @param {number} [min] The minimum of the range\n * @param {number} [max] The maximum of the range\n * @returns {number} Whether or not the element fits inside the boundaries on the given axis\n */\n\nfunction capWithinRange(value, min, max) {\n  if (value > max) {\n    return max;\n  }\n  if (value < min) {\n    return min;\n  }\n  return value;\n}\n/**\n * @param {number[]} [elementDimensions] The dimensions of the element: [width, height]\n * @param {number[]} [position] The desired position of the element: [x, y]\n * @param {number[]} [boundaries] The boundaries of the container the element should be contained in: [minX, minY, maxX, maxY]\n * @param {string} [axis=\"x\"] Which axis to check. Either \"x\" or \"y\"\n * @returns {boolean} Whether or not the element fits inside the boundaries on the given axis\n */\n\nfunction elementFits(elementDimensions, position, boundaries) {\n  var axis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'x';\n  var index = axis === 'y' ? 1 : 0;\n  var min = boundaries[index];\n  var max = boundaries[index + 2];\n  var start = position[index];\n  var end = position[index] + elementDimensions[index];\n  return start >= min && end <= max;\n}\n/**\n * @param {number[]} [elementDimensions] The dimensions of the element: [width, height]\n * @param {number[]} [targetBoundaries] The boundaries of the target the element should attach to: [minX, minY, maxX, maxY]\n * @param {number[]} [containerBoundaries] The boundaries of the container the element should be contained in: [minX, minY, maxX, maxY]\n * @param {number} [preferredDirection=1] Which direction is preferred. Either 1 (right right) or -1 (to left)\n * @param {boolean} [isRootLevel] Flag that indicates if the element is on level 1 (the root level)\n * @param {object} [element] The list element - used to calculate the offset of submenus\n * @returns {object} The determined position and direction of the element: { position: [x, y], direction: 1 | -1 }\n */\n\nfunction getPosition(elementDimensions, targetBoundaries, containerBoundaries) {\n  var preferredDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var isRootLevel = arguments.length > 4 ? arguments[4] : undefined;\n  var element = arguments.length > 5 ? arguments[5] : undefined;\n  var position = [0, 0];\n  var direction = preferredDirection; // x\n\n  position[0] = direction === 1 ? targetBoundaries[0] : targetBoundaries[2] - elementDimensions[0];\n  var xFits = elementFits(elementDimensions, position, containerBoundaries, 'x');\n  if (!xFits) {\n    direction = direction * -1;\n    position[0] = direction === 1 ? targetBoundaries[0] : targetBoundaries[2] - elementDimensions[0];\n  } // y\n\n  position[1] = targetBoundaries[3];\n  var yFits = elementFits(elementDimensions, position, containerBoundaries, 'y');\n  if (!yFits) {\n    position[1] = targetBoundaries[1] - elementDimensions[1];\n    if (!isRootLevel && element) {\n      // if sub-menu and not root level, consider offset\n      var diff = getSubMenuOffset(element);\n      position[1] += diff;\n    }\n  }\n  return {\n    position: position,\n    direction: direction\n  };\n}\nexport { capWithinRange, clickedElementHasSubnodes, focusNode, getFirstSubNode, getNextNode, getParentMenu, getParentNode, getPosition, getSubMenuOffset, getValidNodes, resetFocus };","map":{"version":3,"names":["prefix","resetFocus","el","_el$querySelectorAll","Array","from","querySelectorAll","forEach","node","tabIndex","focusNode","focus","getValidNodes","list","level","dataset","nodes","submenus","concat","filter","child","some","submenu","contains","matches","getNextNode","current","direction","menu","getParentMenu","currentIndex","indexOf","nextNode","getFirstSubNode","querySelector","subnodes","getParentNode","parentNode","closest","getSubMenuOffset","nodeStyles","getComputedStyle","spacings","parseInt","paddingTop","paddingBottom","elementHeight","firstElementChild","offsetHeight","parentMenu","clickedElementHasSubnodes","e","closestFocusableElement","target","tagName","capWithinRange","value","min","max","elementFits","elementDimensions","position","boundaries","axis","arguments","length","undefined","index","start","end","getPosition","targetBoundaries","containerBoundaries","preferredDirection","isRootLevel","element","xFits","yFits","diff"],"sources":["C:/Users/Administrator/Desktop/nerf/node_modules/@carbon/react/es/components/Menu/_utils.js"],"sourcesContent":["/**\n * Copyright IBM Corp. 2016, 2022\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar prefix = 'cds';\nfunction resetFocus(el) {\n  if (el) {\n    var _el$querySelectorAll;\n\n    Array.from((_el$querySelectorAll = el.querySelectorAll('[tabindex=\"0\"]')) !== null && _el$querySelectorAll !== void 0 ? _el$querySelectorAll : []).forEach(function (node) {\n      node.tabIndex = -1;\n    });\n  }\n}\nfunction focusNode(node) {\n  if (node) {\n    node.tabIndex = 0;\n    node.focus();\n  }\n}\nfunction getValidNodes(list) {\n  var level = list.dataset.level;\n  var nodes = [];\n\n  if (level) {\n    var submenus = Array.from(list.querySelectorAll('[data-level]'));\n    nodes = Array.from(list.querySelectorAll(\"li.\".concat(prefix, \"--menu-option\"))).filter(function (child) {\n      return !submenus.some(function (submenu) {\n        return submenu.contains(child);\n      });\n    });\n  }\n\n  return nodes.filter(function (node) {\n    return node.matches(\":not(.\".concat(prefix, \"--menu-option--disabled)\"));\n  });\n}\nfunction getNextNode(current, direction) {\n  var menu = getParentMenu(current);\n  var nodes = getValidNodes(menu);\n  var currentIndex = nodes.indexOf(current);\n  var nextNode = nodes[currentIndex + direction];\n  return nextNode || null;\n}\nfunction getFirstSubNode(node) {\n  var submenu = node.querySelector(\"ul.\".concat(prefix, \"--menu\"));\n\n  if (submenu) {\n    var subnodes = getValidNodes(submenu);\n    return subnodes[0] || null;\n  }\n\n  return null;\n}\nfunction getParentNode(node) {\n  if (node) {\n    var parentNode = node.parentNode.closest(\"li.\".concat(prefix, \"--menu-option\"));\n    return parentNode || null;\n  }\n\n  return null;\n}\nfunction getSubMenuOffset(node) {\n  if (node) {\n    var nodeStyles = getComputedStyle(node);\n    var spacings = parseInt(nodeStyles.paddingTop) + parseInt(nodeStyles.paddingBottom); // styles always in px, convert to number\n\n    var elementHeight = node.firstElementChild.offsetHeight;\n    return elementHeight + spacings || 0;\n  }\n\n  return 0;\n}\nfunction getParentMenu(el) {\n  if (el) {\n    var parentMenu = el.parentNode.closest(\"ul.\".concat(prefix, \"--menu\"));\n    return parentMenu || null;\n  }\n\n  return null;\n}\nfunction clickedElementHasSubnodes(e) {\n  if (e) {\n    var closestFocusableElement = e.target.closest('[tabindex]');\n\n    if ((closestFocusableElement === null || closestFocusableElement === void 0 ? void 0 : closestFocusableElement.tagName) === 'LI') {\n      return getFirstSubNode(closestFocusableElement) !== null;\n    }\n  }\n\n  return false;\n}\n/**\n * @param {number} [value] The value to cap\n * @param {number} [min] The minimum of the range\n * @param {number} [max] The maximum of the range\n * @returns {number} Whether or not the element fits inside the boundaries on the given axis\n */\n\nfunction capWithinRange(value, min, max) {\n  if (value > max) {\n    return max;\n  }\n\n  if (value < min) {\n    return min;\n  }\n\n  return value;\n}\n/**\n * @param {number[]} [elementDimensions] The dimensions of the element: [width, height]\n * @param {number[]} [position] The desired position of the element: [x, y]\n * @param {number[]} [boundaries] The boundaries of the container the element should be contained in: [minX, minY, maxX, maxY]\n * @param {string} [axis=\"x\"] Which axis to check. Either \"x\" or \"y\"\n * @returns {boolean} Whether or not the element fits inside the boundaries on the given axis\n */\n\nfunction elementFits(elementDimensions, position, boundaries) {\n  var axis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'x';\n  var index = axis === 'y' ? 1 : 0;\n  var min = boundaries[index];\n  var max = boundaries[index + 2];\n  var start = position[index];\n  var end = position[index] + elementDimensions[index];\n  return start >= min && end <= max;\n}\n/**\n * @param {number[]} [elementDimensions] The dimensions of the element: [width, height]\n * @param {number[]} [targetBoundaries] The boundaries of the target the element should attach to: [minX, minY, maxX, maxY]\n * @param {number[]} [containerBoundaries] The boundaries of the container the element should be contained in: [minX, minY, maxX, maxY]\n * @param {number} [preferredDirection=1] Which direction is preferred. Either 1 (right right) or -1 (to left)\n * @param {boolean} [isRootLevel] Flag that indicates if the element is on level 1 (the root level)\n * @param {object} [element] The list element - used to calculate the offset of submenus\n * @returns {object} The determined position and direction of the element: { position: [x, y], direction: 1 | -1 }\n */\n\n\nfunction getPosition(elementDimensions, targetBoundaries, containerBoundaries) {\n  var preferredDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var isRootLevel = arguments.length > 4 ? arguments[4] : undefined;\n  var element = arguments.length > 5 ? arguments[5] : undefined;\n  var position = [0, 0];\n  var direction = preferredDirection; // x\n\n  position[0] = direction === 1 ? targetBoundaries[0] : targetBoundaries[2] - elementDimensions[0];\n  var xFits = elementFits(elementDimensions, position, containerBoundaries, 'x');\n\n  if (!xFits) {\n    direction = direction * -1;\n    position[0] = direction === 1 ? targetBoundaries[0] : targetBoundaries[2] - elementDimensions[0];\n  } // y\n\n\n  position[1] = targetBoundaries[3];\n  var yFits = elementFits(elementDimensions, position, containerBoundaries, 'y');\n\n  if (!yFits) {\n    position[1] = targetBoundaries[1] - elementDimensions[1];\n\n    if (!isRootLevel && element) {\n      // if sub-menu and not root level, consider offset\n      var diff = getSubMenuOffset(element);\n      position[1] += diff;\n    }\n  }\n\n  return {\n    position: position,\n    direction: direction\n  };\n}\n\nexport { capWithinRange, clickedElementHasSubnodes, focusNode, getFirstSubNode, getNextNode, getParentMenu, getParentNode, getPosition, getSubMenuOffset, getValidNodes, resetFocus };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}